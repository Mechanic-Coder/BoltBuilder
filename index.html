

  <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Bolt Builder</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.js"></script>

        <!-- earcut script critcal for PolygonMeshBuilder -->
        <script src="https://unpkg.com/earcut@2.1.1/dist/earcut.min.js"></script>
        
        
        <link rel="stylesheet" href="statusBar.css">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
   <body>
    <div id="main" class="teas">
      
      <div id="container">
      <canvas id="renderCanvas" touch-action="none"> </canvas> <!-- touch-action="none" for best results from PEP -->
        <div id="overlaytext" class="CPUoNLY">
          Scroll To Zoom</div>
          <div id="overlaytext2">
            best experience on a computer
            </div>

      <div class="arrow" id="overlayleft">
          <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" fill="currentColor" class="bi bi-caret-left-fill" viewBox="0 0 16 16">
          <path d="M3.86 8.753l5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"/>
        </svg> 
      </div>
      <div class="arrow" id="overlayTop">
        <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" fill="currentColor" class="bi bi-caret-up-fill" viewBox="0 0 16 16">
          <path d="M7.247 4.86l-4.796 5.481c-.566.647-.106 1.659.753 1.659h9.592a1 1 0 0 0 .753-1.659l-4.796-5.48a1 1 0 0 0-1.506 0z"/>
        </svg>
      </div>
      <div class="arrow" id="overlayRight">
        <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" fill="currentColor" class="bi bi-caret-right-fill" viewBox="0 0 16 16">
          <path d="M12.14 8.753l-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"/>
        </svg>
      </div>
      <div class="arrow"  id="overlayBottom">
        <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" fill="currentColor" class="bi bi-caret-down-fill" viewBox="0 0 16 16">
          <path  d="M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"/>
        </svg>
      </div>

      </div>
      
      
      <div id="first">
        <div id="second" >
          <div  id="titleBtnHolder">
          <h1> Bolt Builder </h1>
          <div class="center">
            <button type='button' class="updatebtn" id="Updatebtn">
              <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
              </svg>
              <div>Update Display</div>          
            </button>
          </div>
        </div>
          <div class="card">
            <div class="mids">
              <div class="mid">
                <div class="space">
                  <label>Outer Diameter:</label><input type="number" id="major">
                </div>
                <div class="space">
                  <label> Pitch:</label><input type="number" id="pitch">
                </div>
                <div class="space">
                  <label> Length: </label><input type="number" id="length">
                </div>
              </div>
            </div>    
            <div class="btnHolder">              
              <div id="MattBox">
                <h2> Material Options</h2> 
                <div id="Matts"></div>
                 
              </div>
            </div>        
          <!-- <p id="Str">  </p> -->
          <h2> Tensile Strength</h2>
          
        <div id="progress-bar-container">
            <div class="progress-bar-child progress"></div>
            <div id='dec' class="progress-bar-child shrinker timelapse"></div>
        </div>
        <p id="Str">  </p>
        <button type='button' class="downBTN" id="download"> Download Bolt</button>
        
        <button type='button' class="infoBTN" id="info"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-info-circle-fill" viewBox="0 0 16 16">
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412l-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
        </svg></button>
      </div>
     
        </div>
      </div>
      <div id="popUp">
        <button id="exitBTN" ><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-square-fill" viewBox="0 0 16 16">
          <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm3.354 4.646L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 1 1 .708-.708z"/>
        </svg> </button>
        <h2> Notes</h2>
        <p id="notes">
          <li>Outer Diameter is the size of the threaded section of bolt. </li>
          <li>Pitch determines the thread coarseness</li>
          <li>the bolt can be Downloaded to your pc in a GLTF2 file format</li>
          <li>if you desire to 3d print bolt convert GLTF2 file to a STL file using Blender</li>
          <li>when DownLoaded the environment is removed from file  because its just a big box around the bolt</li>
        </p>
      </div>
    </div>


    <script type="module">
    // things to add
    // about project readme page
    //! DONT think ill do now.  make mtt transtion smoother dont refresh whole page
      import { initScene, changeColor } from "./babylonBoiler.js"
      import { updateGlobal, MathConst } from "./globalClass.js"
      import { materials, BoltEQ } from "./engineCalc.js"
      import { UniThread, createVector3 } from "./threadGen.js"
      
      const Matts = materials
      const helperConst = new MathConst()
      var DefMat = 0
      // var scene = null;
      var GDims = new updateGlobal(12, 1, 2, Matts[DefMat].color)
      console.log(GDims, "base")
      const canvas = document.getElementById("renderCanvas"); // Get the canvas element
      const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
      // var topics = Matts
    
    $(document).ready(function(){
      $('#exitBTN').click(function(){
        // console.log('hey')
        $("#popUp").css("display", "none"); 
        }) 
        
        $('#info').click(function(){
        // console.log('hey')
        $("#popUp").css("display", "block");
        
        }) 

      for (var i = 0; i < Matts.length; i++) { 
        var buttons = $(`<button class="matbtn btnShape" id="mat${i}" > ${Matts[i].name}</button>`)
        buttons.appendTo('#Matts'); 
        $('#mat' + i).click(
          changeMatCallback( i )
         )   
      }  
      $('#download').click(function(){
        // console.log('hey')
        download()
        
        }) 

      $("#major").val(GDims.Gmajor)
      $("#pitch").val(GDims.Gpitch)
      $("#length").val(GDims.Glength)
      $('#Updatebtn').click(()=>{
        updatemat(DefMat)
        displ()
      })

      $('#GMat').change(function(){ 
        updateGlobalParams()
        updateCalcs(DefMat)
        displ()
      });
      updateCalcs(DefMat)
      
    });
    function download() {
      const scene = displ()
        const skybox = scene.meshes.map((M, index)=> {if(M.id == "hdrSkyBox") {
          return true
        }
      return false })
      console.log(skybox)
        for(let b in skybox){
          if(skybox[b] === true){
            scene.meshes[b].dispose()
          }
        }
        console.log(scene.meshes)
        BABYLON.GLTF2Export.GLTFAsync(scene, "3DNew").then((gltf) => {
    gltf.downloadFiles();

});
    }


    var createScene = () => {

      // 1 change
      var AllScene = initScene(engine, canvas)
      
      var scene = AllScene.scene
      var mat = changeColor(scene, GDims.GMat)
      
      makeDisc(mat, GDims.Rad() , GDims.TopOfThread(), helperConst.RotTop())
      makeDisc(mat, GDims.GMin() * .9, GDims.BottomOfChamfer() , helperConst.RotTop())
      BottomChamfer(mat, scene)
      createHead(mat, scene)
      createThread(mat, scene)

      return scene;
      };
      displ()

    function changebtnCss(i) {
        for(var t in Matts ) {
          console.log(t)
          if(t == i) {
            $('#mat' + t).removeClass('matbtn')
          $('#mat' + t).addClass("MatClicked");
          } else {
            $('#mat' + t).removeClass("MatClicked");
            $('#mat' + t).addClass('matbtn')
          }
        }
    }
    function changeMatCallback( i ){
        return function(){
          changebtnCss(i)
          
          updatemat(i)
        }
      }
    function updatemat(i) {
        DefMat = i
        updateGlobalParams()
        const Mat = Matts[i].color
        GDims = new updateGlobal(GDims.Gpitch, GDims.Gmajor, GDims.Glength, Mat)
        updateCalcs(i)
        displ()
    }
    function updateCalcs(i) {
      const Boltprop = new BoltEQ(GDims.Gmajor, GDims.Gpitch, Matts[i].uts)
      console.log(Boltprop)
      updateStrengthBar(Boltprop.MaxLoad())
    }
    function updateStrengthBar(Strength) {
      $('#Str').html(Strength + ' psi');
      var elem = document.getElementById('dec');        
      var unit =  Strength / 30000;
      var perc = 100 -  unit * 10
      if(unit * 10 > 100) {
        perc = 0
      }  
      elem.style.width = perc + '%';
    }
    function updateGlobalParams() {
      const Gmajor = $("#major").val()
      const Gpitch = $("#pitch").val()
      const Glength = $("#length").val()

      if(Gmajor > 15) {
        alert('outer diameter may not exceed 15 inches')
      }
      else if(Gpitch < 2) {
        alert('Pitch may not be less then 2')
      }
      else if(Glength > 25) {
        alert('length may not exceed 25')
      }
      else if(Gmajor < 1 && Gpitch < 10) {
        alert('when pitch is less then 10 the outer diameter must be greater then 1  ')
      }
      else if(Gmajor > 0 && Gpitch > 0 && Glength > 0) {
        GDims = new updateGlobal(Gpitch, Gmajor, Glength, GDims.GMat)
      } else {
        alert('all field need to be filled')
      }
    }

  function createThread(mat, scene) {
    var thread = BABYLON.MeshBuilder.CreateRibbon("t", {
        pathArray: UniThread(GDims.Gpitch, GDims.Gmajor, GDims.Glength)}
        , scene);
    thread.material = mat;
  }
  function BottomChamfer(mat, scene) {
    const top = GDims.GMin();
    console.log(GDims.GMin())
    const bottom = GDims.GMin() * .9;
    var topPoints = drawCircle(top,  GDims.BottomOfThread())
    var bottomPoints = drawCircle(bottom,  GDims.BottomOfChamfer())
    var chamfer = BABYLON.MeshBuilder.CreateRibbon("t", {pathArray: 
      [topPoints, bottomPoints]}, scene);
    chamfer.material = mat;
  }
  function createHead(mat, scene) {
    // flats are 1.5 bigger then major
    // G aka the dots are roughly 1.7 greater then major

    const headRad = (GDims.GMAJ() * 1.7) /2
    // B is the distance from bottom of bolt to start of head
    const B = GDims.TopOfThread()
    // head  width is 1/2 of major
    const WholeT = (B + GDims.Rad())
    const scr = WholeT - B;
    const NewT = scr * .85;
    const T = B + (scr * .9);
    const chamf =   T - scr * .1  
    Sides(mat, scene ,headRad, T, B)
    assignFace(B, mat, headRad)
    // first cilcle then hex
    roof(mat, scene ,headRad, chamf, T)
  }
  function makeDisc(mat, rad, y, orientation) {
    const disc = BABYLON.MeshBuilder.CreateDisc("disc", {radius: rad});
    disc.rotation.x  =  orientation;
    disc.position.y += y
    disc.material = mat;
  }
  function roof(mat, scene ,od, C, H) {
  makeDisc(mat, od * .8, (H - C) + H, helperConst.RotTop())
  var TC = DrawTopChamfer(od * .8 ,  C )
  var BC = DrawTthroughcos(od , H )
  var hex = BABYLON.MeshBuilder.CreateRibbon("t", {pathArray: [ TC, BC]}, scene);
  hex.rotation.x  =  Math.PI
  hex.position.y = H * 2
  hex.material = mat;
  }
  function DrawTthroughcos(od , y) {
    // plots dots allong hexagons  lines 
    // this was tricky
    var path = [];
    var r = od ;
    // y = 40
    // keep below worked
    // const top = Math.sqrt(3)*r 
    // const bot = Math.sqrt(3)*Math.cos(t) + Math.sin(t)
    // const d = top / bot
    // const d = (Math.sqrt(3)*r )/ (Math.sqrt(3)*Math.cos(t) + Math.sin(t))
    
    var d = 0
    // rad is how many degrees are in each segment of polygon hexagon is 60 deg
    const rad = 60 * Math.PI/180
    for (var i = 0; i <= Math.PI * 2 + Math.PI / 60   ; i += Math.PI / 60   ) {

      var t = i % rad
      d = (Math.sqrt(3)*r )/ (Math.sqrt(3)*Math.cos(t) + Math.sin(t))
      path.push( new BABYLON.Vector3(d * Math.sin(i), y, d * Math.cos(i)));
    }
    return path;
  }
  function DrawTopChamfer(od, y) {
    var path = [];
        for (  var i = 0; i <= Math.PI * 2 + Math.PI / 60   ; i += Math.PI / 60) {
      path.push( new BABYLON.Vector3(od * Math.sin(i), y, od * Math.cos(i))); 
    }
    return path;
  }
  function  assignFace(y, mat, od) {
    var lidss = creatHexFace(od)
    var bottomFace = lidss.build();
    bottomFace.position.y += y ;
    bottomFace.material = mat;
  }
  function creatHexFace(od) {
    var Hexface = drawHexFace(od)
    // earcut script required
    return new BABYLON.PolygonMeshBuilder("poly", Hexface);
  }
  function  Sides(mat, scene ,od, T, B) {
    var TH = DrawHex(od, T)
    var BH = DrawHex(od, B)
    var hex = BABYLON.MeshBuilder.CreateRibbon("t", {pathArray: [TH, BH]}, scene);
    hex.material = mat;
  
  }
  function DrawHex(od, y) {
    var path = [];
    for (var i = 0; i < Math.PI * 2 + Math.PI / 6 ; i += Math.PI * 2 / 6 ) {
      path.push( createVector3(od, y, od, i) );
    }
    return path;
  }
  function drawHexFace(od) {
    var path = [];
    for (var i = 0; i < Math.PI * 2 + Math.PI / 6 ; i += Math.PI * 2 / 6 ) {
      path.push(new BABYLON.Vector2(od * Math.sin(i), od * Math.cos(i))) 
    }
    return path;
  }
  function drawCircle(od, y) {
    var path = [];
    for (var i = 0; i < GDims.PieHalfRevs() ; i += helperConst.Clarity()   ) {
      path.push( createVector3(od, y, od, i) );
    }
    return path;
  }
  
  function displ() {  
        const scene = createScene(); 
        engine.runRenderLoop(function () {
                scene.render();
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        
        });
        return scene
  }
    </script>
   </body>
</html>